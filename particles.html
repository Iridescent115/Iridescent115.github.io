<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 手势粒子系统</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            text-align: center;
        }
        .lil-gui {
            --background-color: rgba(0, 0, 0, 0.8);
            --widget-color: #ccc;
            --hover-color: #fff;
            --focus-color: #0af;
            --number-color: #0af;
            --string-color: #0fa;
        }
        #video {
            display: none;
        }
    </style>
</head>
<body>
    <div id="loading">
        <p>正在启动摄像头和3D引擎...</p>
        <p id="loading-message"></p>
    </div>
    <div id="container"></div>
    <video id="video"></video>

    <!-- Core Libraries -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js",
                "@mediapipe/drawing_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675469240/drawing_utils.js",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675469240/camera_utils.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.js';
        import { Hands, HAND_CONNECTIONS } from '@mediapipe/hands';
        import { drawConnectors, drawLandmarks } from '@mediapipe/drawing_utils';
        import { Camera } from '@mediapipe/camera_utils';

        // --- Basic Setup ---
        const loadingEl = document.getElementById('loading');
        const loadingMessageEl = document.getElementById('loading-message');
        const container = document.getElementById('container');
        const videoElement = document.getElementById('video');

        let scene, camera, renderer, particles, controls;
        let handData = null;

        const PARAMS = {
            particleColor: 0x00ffff,
            shape: 'Heart',
            fullscreen: false
        };

        // --- Main Execution ---
        init();

        function init() {
            // 1. Setup Three.js Scene
            setupThree();

            // 2. Setup Hand Tracking
            setupHandTracking();

            // 3. Setup UI
            setupUI();
            
            // 4. Start Animation Loop
            animate();
        }

        function setupThree() {
            loadingMessageEl.innerText = '初始化3D场景...';
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 25;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Create initial particle system
            createParticleSystem();

            window.addEventListener('resize', onWindowResize, false);
        }

        function setupHandTracking() {
            loadingMessageEl.innerText = '初始化手势识别...';
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);

            const cameraUtil = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 1280,
                height: 720
            });
            cameraUtil.start();
        }
        
        function onHandResults(results) {
            if (!loadingEl.hidden) {
                loadingEl.hidden = true;
            }
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handData = results.multiHandLandmarks[0]; // Get the first hand
            } else {
                handData = null;
            }
        }
        
        function setupUI() {
            const gui = new GUI();
            gui.addColor(PARAMS, 'particleColor').name('粒子颜色').onChange(updateParticleColor);
            gui.add(PARAMS, 'shape', ['Heart', 'Flower', 'Saturn', 'ThumbUp']).name('粒子形状').onChange(switchShape);
            
            const fullscreenCtrl = {
                toggle: () => {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen();
                    } else {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        }
                    }
                }
            };
            gui.add(fullscreenCtrl, 'toggle').name('全屏/退出');
        }

        function createParticleSystem() {
            // Placeholder for particle geometry
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(5000 * 3); // Max 5000 particles
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: PARAMS.particleColor,
                size: 0.2,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            switchShape(); // Create the initial shape
        }

        function updateParticleColor() {
            particles.material.color.set(PARAMS.particleColor);
        }

        function switchShape() {
            let points;
            switch(PARAMS.shape) {
                case 'Heart':
                    points = generateHeartPoints();
                    break;
                case 'Flower':
                    points = generateFlowerPoints();
                    break;
                case 'Saturn':
                    points = generateSaturnPoints();
                    break;
                case 'ThumbUp':
                    points = generateThumbUpPoints();
                    break;
                default:
                    points = generateHeartPoints();
            }
            updateParticleGeometry(points);
        }
        
        function updateParticleGeometry(points) {
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i++) {
                positions[i] = (i < points.length) ? points[i] : 10000; // Hide unused particles
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.computeBoundingSphere();
        }

        // --- Point Generation Functions (To be implemented) ---
        function generateHeartPoints() {
            const points = [];
            const scale = 10;
            for (let t = 0; t < Math.PI * 2; t += 0.01) {
                const x = scale * 1.6 * Math.pow(Math.sin(t), 3);
                const y = scale * (1.3 * Math.cos(t) - 0.5 * Math.cos(2*t) - 0.2 * Math.cos(3*t) - 0.1 * Math.cos(4*t));
                const z = 0;
                points.push(x, y, z);
            }
            return points;
        }

        function generateFlowerPoints() {
            const points = [];
            const petals = 6;
            const radius = 8;
            for (let i = 0; i < 2000; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * radius * (0.5 + 0.5 * Math.sin(angle * petals));
                const x = r * Math.cos(angle);
                const y = r * Math.sin(angle);
                const z = (Math.random() - 0.5) * 2;
                points.push(x, y, z);
            }
            return points;
        }

        function generateSaturnPoints() {
            const points = [];
            // Planet
            for (let i = 0; i < 2000; i++) {
                const phi = Math.acos(-1 + (2 * i) / 2000);
                const theta = Math.sqrt(2000 * Math.PI) * phi;
                const r = 6;
                const x = r * Math.cos(theta) * Math.sin(phi);
                const y = r * Math.sin(theta) * Math.sin(phi);
                const z = r * Math.cos(phi);
                points.push(x, y, z);
            }
            // Rings
            for (let i = 0; i < 2000; i++) {
                const r = 8 + Math.random() * 3;
                const angle = Math.random() * Math.PI * 2;
                const x = r * Math.cos(angle);
                const y = r * Math.sin(angle);
                const z = (Math.random() - 0.5) * 0.5;
                points.push(x, y, z);
            }
            return points;
        }

        function generateThumbUpPoints() {
            // Simplified procedural thumb up
            const points = [];
            // Palm
            for(let i=0; i<1000; i++) {
                points.push(
                    (Math.random() - 0.5) * 8, 
                    (Math.random() - 0.5) * 10 - 5, 
                    (Math.random() - 0.5) * 2
                );
            }
            // Thumb
            for(let i=0; i<500; i++) {
                points.push(
                    (Math.random() - 0.5) * 2 + 5,
                    (Math.random() - 0.5) * 2 + 2,
                    (Math.random() - 0.5) * 2
                );
            }
            for(let i=0; i<500; i++) {
                 points.push(
                    (Math.random() - 0.5) * 2 + 3,
                    (Math.random() - 0.5) * 5 + 5,
                    (Math.random() - 0.5) * 2
                );
            }
            return points;
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            controls.update();
            
            // --- Particle Interaction Logic (To be implemented) ---
            if (handData) {
                // Example: make particles follow hand
                const wrist = handData[0];
                const targetX = (wrist.x - 0.5) * 50;
                const targetY = -(wrist.y - 0.5) * 50;
                
                // Smoothly move the particle system
                particles.position.x += (targetX - particles.position.x) * 0.05;
                particles.position.y += (targetY - particles.position.y) * 0.05;

                // Calculate hand openness
                const thumbTip = handData[4];
                const indexTip = handData[8];
                const pinkyTip = handData[20];
                const palmCenter = {
                    x: (handData[0].x + handData[5].x + handData[17].x) / 3,
                    y: (handData[0].y + handData[5].y + handData[17].y) / 3,
                };
                
                const d1 = Math.hypot(thumbTip.x - palmCenter.x, thumbTip.y - palmCenter.y);
                const d2 = Math.hypot(indexTip.x - palmCenter.x, indexTip.y - palmCenter.y);
                const d3 = Math.hypot(pinkyTip.x - palmCenter.x, pinkyTip.y - palmCenter.y);

                const openness = (d1 + d2 + d3) / 0.8; // Normalize
                const scale = 1 + openness * 2;
                
                // Animate scale
                particles.scale.x += (scale - particles.scale.x) * 0.1;
                particles.scale.y += (scale - particles.scale.y) * 0.1;
                particles.scale.z += (scale - particles.scale.z) * 0.1;

            } else {
                // If no hand, return to default state
                particles.position.x += (0 - particles.position.x) * 0.05;
                particles.position.y += (0 - particles.position.y) * 0.05;
                particles.scale.x += (1 - particles.scale.x) * 0.1;
                particles.scale.y += (1 - particles.scale.y) * 0.1;
                particles.scale.z += (1 - particles.scale.z) * 0.1;
            }

            particles.rotation.x += 0.0005;
            particles.rotation.y += 0.001;

            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
